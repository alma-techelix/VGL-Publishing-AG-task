 # Monorepo Overview

 This repository contains a lightweight web application split into two apps that live side by side:

 - `packages/backend/` — PHP HTTP service (Swoole + Doctrine) exposing read-only endpoints.
 - `packages/frontend/` — Nuxt 4 (Vue 3) frontend consuming the backend API.

 The fictional scenario: an existing backend and a separate frontend have been brought together into a single repository. The objective is to run and deploy them in an AWS environment while keeping developer experience (DX) smooth for day-to-day work.

 ## Tech Stack
 - Backend: PHP 8.1+, Swoole HTTP server, Doctrine ORM/DBAL, SQLite (dev) / MySQL (prod).
 - Frontend: Nuxt 4, Vue 3, Vite, Tailwind CSS.

 ## Goals
 - Keep local development fast and simple for both apps.
 - Provide a clear path to build, test, and deploy each app independently.
 - Use AWS primitives that are familiar and maintainable over time.

 ## Repository Structure
 ```
 packages/
   backend/   # PHP service, Composer scripts, .env config
   frontend/  # Nuxt app, pnpm scripts, runtime config
 ```

 ## Local Development

### Option 1: Docker (Recommended)
Development uses SQLite (bundled `dev.db`) for zero‑setup speed. MySQL runs only under the `production` profile.

```bash
# Start dev (frontend + backend with SQLite)
docker compose up -d backend frontend

# Or simply (starts only defined dev services; MySQL omitted by profile):
docker compose up -d

# Check service health
docker compose ps

# View logs
docker compose logs -f backend

# Stop services
docker compose down
```

Dev service URLs:
- Frontend: http://localhost:3000
- Backend API: http://localhost:8080
- (SQLite file at `packages/backend/data/dev.db`)

### Makefile Shortcuts
After cloning you can use the provided `Makefile`:
```bash
make up          # start dev stack (SQLite)
make smoke       # run smoke checks (health + sample endpoint)
make logs        # tail logs
make down        # stop stack
make prod-up     # start production profile (MySQL + prod images)
make prod-smoke  # run smoke against prod profile endpoints
```

To run with MySQL (e.g., production-like):
```bash
docker compose --profile production up -d mysql backend-prod frontend-prod
```
Production-profile URLs:
- Frontend: http://localhost:3001
- Backend API: http://localhost:8081
- MySQL: localhost:3307 (container 3306 mapped to 3307)

 ### Option 2: Native Development
 - Backend: see `packages/backend/README.md` for Composer scripts, `.env` setup, and endpoints.
 - Frontend: see `packages/frontend/README.md` for pnpm scripts and runtime configuration.

 Typical flow:
 1) Start backend API (defaults to `http://127.0.0.1:8080`).
 2) Start frontend dev server (defaults to `http://localhost:3000`).

 For detailed app instructions, refer to the READMEs in `packages/backend/` and `packages/frontend/`.

 ## Production Deployment

 ### Docker Production Build
 ```bash
 # Build production images
 docker-compose --profile production build
 
 # Run production services
 docker-compose --profile production up -d
 ```
 
 Production services:
 - Frontend: http://localhost:3001
 - Backend API: http://localhost:8081

 ## Environment Configuration

These are the minimal environment variables now in use.

Dev (`.env.development`):
```
DB_DRIVER=sqlite
DB_PATH=data/dev.db
HTTP_HOST=127.0.0.1
HTTP_PORT=8080
NUXT_PUBLIC_API_ENVIRONMENT=dev
NUXT_PUBLIC_API_BASE_URL_DEV=http://localhost:8080
PORT=3000
```

Prod (`.env.production`):
```
# Database configuration injected via AWS Secrets Manager in ECS deployment
# All DB_* variables (HOST, PORT, NAME, USER, PASS, DRIVER) come from Secrets Manager
HTTP_HOST=0.0.0.0
HTTP_PORT=8080
NUXT_PUBLIC_API_ENVIRONMENT=prod
# API URL dynamically set by Terraform: http://ALB_DNS_NAME/api
NUXT_PUBLIC_API_BASE_URL_PROD=http://backend-prod:8080  # Docker compose fallback
PORT=3000
```

Reference templates:
- `.env.example` (optional scaffold)
- `.env.development` (local dev)
- `.env.production` (production profile - overridden by Terraform in AWS)

## AWS Deployment

The repository includes comprehensive Terraform infrastructure for production AWS deployment:

### Infrastructure Components
- **ECS Fargate** cluster for serverless containerized applications
- **Aurora MySQL** database cluster with automatic backups
- **Application Load Balancer** with SSL termination and path-based routing
- **VPC** with public/private subnets across multiple availability zones
- **AWS Secrets Manager** for secure database configuration storage
- **Auto-scaling** policies for high availability
- **CloudWatch** monitoring, dashboards, and alerting
- **Cost optimization** features (configurable NAT Gateway, Multi-AZ)

### Key Security Features
- All database credentials stored in AWS Secrets Manager
- Dynamic API URLs generated by Terraform (no hardcoded endpoints)
- Least-privilege IAM roles and policies
- Encryption at rest and in transit
- Network segmentation with security groups

### Deployment
```bash
# Navigate to terraform directory
cd terraform

# Initialize Terraform
terraform init

# Plan deployment
terraform plan -var-file="terraform.tfvars"

# Deploy infrastructure
terraform apply -var-file="terraform.tfvars"

# Get deployment outputs
terraform output
```

### Configuration
Create a `terraform.tfvars` file:
```hcl
aws_region = "us-east-1"
environment = "prod"
project_name = "vgl-challenge"

# Container images from CI/CD pipeline
backend_image = "public.ecr.aws/your-prefix/vgl-backend:latest"
frontend_image = "public.ecr.aws/your-prefix/vgl-frontend:latest"

# Cost optimization (optional)
enable_nat_gateway = false  # Save ~$45/month
enable_multi_az = false     # Save ~$60/month
```

See `terraform/` directory for complete infrastructure as code and `TERRAFORM_GUIDE.md` for detailed documentation.

## CI/CD Pipeline

Comprehensive GitHub Actions workflows for automated testing, building, and deployment:

### What Gets Tested (No AWS Required)
- **Backend**: PHP 8.3 testing (PHPUnit, PHPStan, PHPCS) with MySQL test database
- **Frontend**: Node.js 20 testing (Vitest, ESLint, TypeScript checking)
- **Docker Builds**: Multi-architecture images (AMD64/ARM64)
- **Security Scanning**: Trivy vulnerability scanner with SARIF reports
- **Integration Testing**: Full docker-compose stack validation

### Workflow Triggers
- Push to `main` or `develop` branches
- Pull requests to `main`
- Manual workflow dispatch (with skip deployment option)
- File changes in respective `packages/` directories

### Testing the Pipeline
```bash
# Run the interactive demo
./test-cicd-demo.sh

# Or manually trigger workflows at:
# https://github.com/YOUR_USERNAME/YOUR_REPO/actions
```

**Interview Note**: 80% of the CI/CD pipeline works without AWS setup - perfect for demonstration!

## Architecture & Security

### Dynamic Configuration
- **API URLs**: Automatically generated by Terraform (no hardcoded endpoints)
- **Database Config**: All connection parameters stored in AWS Secrets Manager
- **Environment Aware**: Same code works locally and in AWS production

### Path-Based Routing
The Application Load Balancer routes requests intelligently:
- `/api/*` → Backend ECS service
- `/health` → Backend health checks  
- `/*` → Frontend application

### Documentation
- **`PLAN.md`** - Implementation approach and architectural decisions
- **`DATABASE_SECURITY.md`** - Secrets Manager integration details
- **`API_CONFIGURATION.md`** - Dynamic URL configuration explained
- **`CI_CD_TESTING.md`** - Guide for testing the pipeline
- **`TERRAFORM_GUIDE.md`** - Infrastructure code organization

## Quick Start

```bash
# Clone and start local development
git clone <repository>
cd vgl-devops-challenge-main

# Start with one command
make up

# Run health checks
make smoke

# View the application
open http://localhost:3000
```
